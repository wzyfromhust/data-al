<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>19_python内置常用算法和数据结构 - Python 数据结构与算法视频教程</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../../css/extra.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "19_python\u5185\u7f6e\u5e38\u7528\u7b97\u6cd5\u548c\u6570\u636e\u7ed3\u6784";
        var mkdocs_page_input_path = "19_python\u5185\u7f6e\u5e38\u7528\u7b97\u6cd5\u548c\u6570\u636e\u7ed3\u6784/builtins.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> Python 数据结构与算法视频教程
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">课程简介</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../00_%E8%AF%BE%E7%A8%8B%E7%AE%80%E4%BB%8B%E4%B9%8B%E7%AC%A8%E6%96%B9%E6%B3%95%E5%AD%A6%E7%AE%97%E6%B3%95/why_and_how_to_learn/">00_课程简介之笨方法学算法</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../01_%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/ADT_OOP/">01_抽象数据类型和面向对象编程</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../02_%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%97%E8%A1%A8/array_and_list/">02_数组和列表</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../03_%E9%93%BE%E8%A1%A8/linked_list/">03_链表</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../04_%E9%98%9F%E5%88%97/queue/">04_队列</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../05_%E6%A0%88/stack/">05_栈</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../06_%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/big_o/">06_算法分析</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../07_%E5%93%88%E5%B8%8C%E8%A1%A8/hashtable/">07_哈希表</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../08_%E5%AD%97%E5%85%B8/dict/">08_字典</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../09_%E9%9B%86%E5%90%88/set/">09_集合</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../10_%E9%80%92%E5%BD%92/recursion/">10_递归</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../11_%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE%E4%B8%8E%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/search/">11_线性查找与二分查找</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../12_%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/basic_sort/">12_基本排序算法</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">13_高级排序算法</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../13_%E9%AB%98%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/advanced_sorting/">高级排序算法</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13_%E9%AB%98%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/merge_sort/">分治法与归并排序</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../13_%E9%AB%98%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/quick_sort/">快速排序</a>
                  </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../14_%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/tree/">14_树与二叉树</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../15_%E5%A0%86%E4%B8%8E%E5%A0%86%E6%8E%92%E5%BA%8F/heap_and_heapsort/">15_堆和堆排序</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../16_%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/priority_queue/">16_优先级队列</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../17_%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/binary_search_tree/">17_二叉查找树</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../18_%E5%9B%BE%E4%B8%8E%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/graph/">18_图与图的遍历</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="#">19_python内置常用算法和数据结构</a>
    <ul class="current">
    </ul>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../20_%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/interview/">20_面试指南</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">Python 数据结构与算法视频教程</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">19_python内置常用算法和数据结构</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="python">Python 刷题常用内置算法和数据结构</h1>
<p>相信到这里大家对常用的数据结构和算法及其实现都比较熟悉了。
之前在每章的数据结构和算法中涉及到的章节我都会提到对应的 python 内置模块，一般如果内置的可以满足需求，我们优先使用内置模块，
因为在性能和容错性方面内置模块要好于我们自己实现（比如有些是 c 实现的）。本章我们不会再对每个模块的原理详细说明，仅列举出一些常见模块供大家参考，
如果有需要最好的学习方式就是参考 Python 的官方文档。很多高级的数据结构我们也可以通过 google 搜索现成的库拿来直接用。</p>
<ul>
<li>常用内置数据类型：list, tuple, dict, set, frozenset</li>
<li>collections 模块：Counter(计数器), deque(双端队列), OrderedDict(有序字典)，defaultdict(默认值字典)</li>
<li>heapq: 堆操作</li>
<li>bisect: 二分查找</li>
</ul>
<p>下边我列了一个常用 python 内置数据结构和算法的表格，如果有遗漏可以在 issue 中提出。确保你了解这些数据结构和算法的使用以及时间、空间复杂度。</p>
<table>
<thead>
<tr>
<th>数据结构/算法</th>
<th>语言内置</th>
<th>内置库</th>
</tr>
</thead>
<tbody>
<tr>
<td>线性结构</td>
<td>list(列表)/tuple(元组)</td>
<td>array(数组，不常用)/collections.namedtuple</td>
</tr>
<tr>
<td>链式结构</td>
<td></td>
<td>collections.deque(双端队列)</td>
</tr>
<tr>
<td>字典结构</td>
<td>dict(字典)</td>
<td>collections.Counter(计数器)/OrderedDict(有序字典)/defaultdict(默认字典)</td>
</tr>
<tr>
<td>集合结构</td>
<td>set(集合)/frozenset(不可变集合)</td>
<td></td>
</tr>
<tr>
<td>排序算法</td>
<td>sorted</td>
<td></td>
</tr>
<tr>
<td>二分算法</td>
<td></td>
<td>bisect模块</td>
</tr>
<tr>
<td>堆算法</td>
<td></td>
<td>heapq模块</td>
</tr>
<tr>
<td>优先级队列</td>
<td></td>
<td>queue.PriorityQueue/heapq</td>
</tr>
<tr>
<td>缓存算法</td>
<td></td>
<td>functools.lru_cache(Least Recent Used, python3)/cache</td>
</tr>
</tbody>
</table>
<h1 id="_1">一些坑</h1>
<p>如果你使用 python2 or python3 刷题（比如力扣leetcode），有一些坑或者技巧需要注意：</p>
<ul>
<li>字典顺序。python3 和 python2 的 dict 有所用不同，python3.7 之后的 dict 会保持插入顺序(不是字典序), python2 不要依赖 dict 迭代顺序，请使用 OrderedDict</li>
<li>矩阵。正确初始化一个不可变对象的二维数组：<code>dp = [ [0]*col for _ in range(row) ]</code>，不要用 <code>dp = [[0] * n] * m</code>， 否则里边都
引用的同一个 list，修改一个都会变。<code>[[0 for _ in range(col)] for _ in range(row)]</code> 也可以(稍慢)，因为数字 0 是不可变对象</li>
<li>深浅拷贝。经常在回溯题中需要<code>res,path=[],[]</code>，path 是用来回溯的路径。找到一个结果的时候需要用 <code>res.append(path[:])</code> 而
不是<code>res.append(path)#错！</code> ，因为这里append的path的引用，之后修改了 path 结果就是错的！(或者用copy模块，不过不如[:]语法简洁)</li>
<li>int范围。python在数值范围建议用：<code>MAXINT = 2**63-1; MININT = -2**63</code> 。因为 python2 sys.maxint 和 python3 sys.maxsize 不统一</li>
<li>优先级队列：使用内置queue.PriorityQueue or heapq ，定义一个 Item 类实现"小于" 魔术方法就可以实现，下边有代码演示</li>
<li>缓存。python3 的 functools 模块自带了 cache(等价于lru_cache(maxsize=None)) 和 lru_cache 装饰器，在一些需要递归记忆化搜索的时候会很方便</li>
<li>除法变更：python2和 python3 除法做了变更要注意。还有负数除法。 python2 <code>int(6/-123)==-1, int(-3/2)==-2</code>，但是 python3 <code>int(6/-123)==0, int(-3/2)==-1</code>。
正数的整数除法统一用"//"。比如二分求中间值 <code>mid=(l+r)//2</code> 或者 <code>mid=l+(r-l)//2</code>，因为python天生支持大数不会溢出两种写法都行。负数整数除法统一写 int(a/b)。
凡是遇到除法运算的题目建议统一使用 python3 提交。</li>
<li>自定义排序函数。python2 可以用 <code>nums.sort(cmp=lambda a, b: a - b)</code>，但是python3移除了cmp参数。
python3如果想要用自定义排序函数可以使用 functools.cmp_to_key 函数改成 <code>nums.sort(key=cmp_to_key(lambda a, b: a - b))</code></li>
</ul>
<h1 id="python_1">python 递归暴栈(栈溢出)</h1>
<p>python 递归函数默认递归深度比较小，你可以通过 <code>sys.getrecursionlimit()</code> 函数打印出来。
我在 mac 机器上测试的时候，以下结果 python2 输出 1000。这就导致一些递归函数测试用例稍微多一些就会报错。
(一个用例超过上千个数据就会报错了)</p>
<pre><code class="language-py">import sys
print(sys.getrecursionlimit()) # 我的 mac 机器上输出 1000
</code></pre>
<p>可以把以下代码设置最大栈深度，放到文件开头，在牛客上提交代码的时候可以避免一些递归代码报错。
(leetcode 似乎给设置了，类似的题目发现力扣上提交不会栈溢出但是在牛客就会)</p>
<pre><code class="language-py">import sys
sys.setrecursionlimit(100000) # 设置函数栈深度足够大，避免栈溢出错误
</code></pre>
<h1 id="python-int">python int 值范围</h1>
<pre><code># 乘方 （比较推荐⭐️，py2/3 都兼容不容易出错)
MAXINT = 2**63-1
MININT = -2**63

# py3
import sys
MAXINT = sys.maxsize
MININT = -sys.maxsize - 1

# py2
sys.maxint

# 位运算
MAXINT = (1&lt;&lt;63) - 1
MININT = ~MAXINT
</code></pre>
<h1 id="python_2">python 负数位运算的坑</h1>
<ol>
<li>Python3 中的整型是补码形式存储的</li>
<li>Python3 中 bin 一个负数（十进制表示），输出的是它的原码的二进制表示加上个负号</li>
<li>为了获得负数（十进制表示）的补码，需要手动将其和十六进制数 0xffffffff 进行按位与操作，得到结果是个十六进制数，再交给 bin() 进行输出，
得到的才是你想要的补码表示。</li>
</ol>
<pre><code class="language-py"># 整数转换 https://leetcode-cn.com/problems/convert-integer-lcci/
class Solution:
    def convertInteger(self, A: int, B: int) -&gt; int:
        return bin((A &amp; 0xffffffff) ^ (B &amp; 0xffffffff)).count('1')
</code></pre>
<p>参考：
- https://www.runoob.com/w3cnote/python-negative-storage.html
- https://leetcode-cn.com/problems/convert-integer-lcci/solution/python3-zhu-yi-qi-dui-yu-fu-shu-de-cun-chu-fang-sh/</p>
<h1 id="python-list">python list 技巧</h1>
<pre><code class="language-py"># 排序嵌套 list，比如元素值是一个 tuple 或者 list
l = [('a', 1), ('c', 2), ('b',3)]
sorted(l, key=lambda p:p[0]) # 根据第1个值排序，[('a', 1), ('b', 3), ('c', 2)]
sorted(l, key=lambda p:p[1]) # 根据第2个值排序，[('a', 1), ('c', 2), ('b', 3)]
sorted(l, key=lambda p:(-p[0], p[1])) # 先根据第一个倒排，如果相等再根据第二个正排序

# 同时获取最大值的下标和值
l = [1,2,5,4,3]
maxi, maxval = max(enumerate(l), key=lambda iv: iv[1]) # 2, 5

# python3 排序list自定义函数(python2 直接用 cmp 参数， python3 需要用 cmp_to_key 转成 key 参数)
from functools import cmp_to_key
nums = [3,2,1,4,5]
sorted(nums, key=cmp_to_key(lambda a,b: a-b) ) # [1 ,2 ,3, 4, 5]
sorted(nums, key=cmp_to_key(lambda a,b: b-a) ) # [5, 4, 3, 2, 1]

# 一行代码判断列表是否有序
issorted = all(l[i] &lt;= l[i+1] for i in range(len(l) - 1))

# python3 一行代码求前缀和
from itertools import accumulate
presums = list(accumulate([1,2,3])) # [1, 3, 6]

# 一行代码求矩阵元素总和 https://stackoverflow.com/questions/10713150/how-to-sum-a-2d-array-in-python
allsum = sum(map(sum, matrix)) # 或者 allsum = sum((sum(row) for row in matrix))
# 一行代码判断一个元素是否在矩阵中，比如判断 1 是否在矩阵matrix中
any(1 in row for row in matrix)
# 一行代码获取矩阵最大、最小值
maxval = max(map(max, matrix))
</code></pre>
<h1 id="python-dict">python dict 技巧</h1>
<pre><code class="language-py"># python 根据 key，value 排序字典
d = {'d': 4, 'a': 1, 'b': 2, 'c':3}
# dict sort by **key** and reverse
dict(sorted(d.items()))  # {'a': 1, 'b': 2, 'c': 3, 'd': 4}
dict(sorted(d.items(), reverse=True)) # {'d': 4, 'c': 3, 'b': 2, 'a': 1}

# dict sort by **value** and reverse
dict(sorted(d.items(), key = lambda kv:kv[1])) # {'a': 1, 'b': 2, 'c': 3, 'd': 4}
dict(sorted(d.items(), key = lambda kv:kv[1], reverse=True)) # {'d': 4, 'c': 3, 'b': 2, 'a': 1}

# 获取字典对应的最大值对应的 key,value
mydict = {'A':4,'B':10,'C':0,'D':87}
maximum = max(mydict, key=mydict.get)  # Just use 'min' instead of 'max' for minimum.
maxk, maxv = maximum, mydict[maximum]
# 或者
maxk, maxv = max(mydict.items(), key=lambda k: k[1])

# 支持默认值的有序字典 (OrderedDict and defaultdict)  (注意是 key 插入顺序不是字典序)
# https://stackoverflow.com/questions/6190331/how-to-implement-an-ordered-default-dict
od = OrderedDict()  # collections.OrderedDict()
od[i] = od.get(i, 0) + 1 # 间接实现了 defaultdict(int) ，同时保持了插入字典的 key 顺序
</code></pre>
<h1 id="_2">链表题目调试函数</h1>
<pre><code class="language-py"># 编写链表题目经常用到的一些通用函数和调试函数，定义等，方便代码调试

class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

    def __str__(self):
        return 'Node({})'.format(self.val)

    # 用来输出调试
    __repr__ = __str__


# 缩写，单测方便写，比如构建链表 1-&gt;2-&gt;3  N(1, N(2, N(3)))
N = Node = ListNode


def to_list(head):
    &quot;&quot;&quot;linked list to python []&quot;&quot;&quot;
    res = []
    curnode = head
    while curnode:
        res.append(curnode.val)
        curnode = curnode.next
    return res


def gen_list(nums):
    &quot;&quot;&quot;用数组生成一个链表方便测试 [1,2,3] 1-&gt;2-&gt;3
    &quot;&quot;&quot;
    if not nums:
        return None
    head = ListNode(nums[0])
    pre = head
    for i in range(1, len(nums)):
        node = ListNode(nums[i])
        pre.next = node
        pre = node
    return head


def print_list(head):
    &quot;&quot;&quot;打印链表&quot;&quot;&quot;
    cur = head
    res = &quot;&quot;
    while cur:
        res += &quot;{}-&gt;&quot;.format(cur.val)
        cur = cur.next
    res += &quot;nil&quot;
    print(res)
</code></pre>
<h1 id="_3">内置库实现优先级队列的三种方式</h1>
<pre><code class="language-py">def test_buildin_PriorityQueue():  # python3
    &quot;&quot;&quot;
    测试内置的 PriorityQueue
    https://pythonguides.com/priority-queue-in-python/
    &quot;&quot;&quot;
    from queue import PriorityQueue
    q = PriorityQueue()
    q.put((10, 'Red balls'))
    q.put((8, 'Pink balls'))
    q.put((5, 'White balls'))
    q.put((4, 'Green balls'))
    while not q.empty():
        item = q.get()
        print(item)


def test_buildin_heapq_as_PriorityQueue():
    &quot;&quot;&quot;
    测试使用 heapq 实现优先级队列，保存一个 tuple 比较元素(tuple第一个元素是优先级)
    实际上是利用了元组tuple比较从第一个开始比较的性质
    &quot;&quot;&quot;
    import heapq
    s_roll = []
    heapq.heappush(s_roll, (4, &quot;Tom&quot;))
    heapq.heappush(s_roll, (1, &quot;Aruhi&quot;))
    heapq.heappush(s_roll, (3, &quot;Dyson&quot;))
    heapq.heappush(s_roll, (2, &quot;Bob&quot;))
    while s_roll:
        deque_r = heapq.heappop(s_roll)
        print(deque_r)


# python3 没有了 __cmp__ 魔法函数 https://stackoverflow.com/questions/8276983/why-cant-i-use-the-method-cmp-in-python-3-as-for-python-2
class Item:
    def __init__(self, key, weight):
        self.key, self.weight = key, weight

    def __lt__(self, other): # heapq 源码实现只用了 小于 比较，这里定义了就可以 push 一个 item 类
        return self.weight &lt; other.weight

#   def __eq__(self, other): # 这个可以省略，只要定义了 __lt__ 魔法函数就可以了
#       return self.weight == other.weight
#
#   def __str__(self):
#       return '{}:{}'.format(self.key,self.weight)

# Item.__lt__ = lambda self, other: self.weight &lt; other.weight # 对于已有的类，直接加一句就可以实现作为 heap item 了

def test_heap_item():
    &quot;&quot;&quot;
    测试使用 Item 类实现优先级队列，因为 heapq 内置使用的是小于运算法，
    重写魔术 &lt; 比较方法即可实现
    &quot;&quot;&quot;
    import heapq
    pq = []
    heapq.heappush(pq, Item('c', 3))
    heapq.heappush(pq, Item('a', 1))
    heapq.heappush(pq, Item('b', 2))
    while pq:
        print(heapq.heappop(pq))
</code></pre>
<h1 id="python_3">python 如何实现最大堆</h1>
<p>python自带了heapq 模块实现了最小堆(min-heaq)，但是如果想要实现最大堆(max-heap)，有几种实现方式：</p>
<ol>
<li>对放入的数字取反。比如 10 放入 -10 ，然后取出来的时候再取反。个人倾向于这种，可以自己封装一个类防止来回取反搞晕</li>
<li>直接根据 heapq 模块的函数封装几个最大堆的函数，也是通过取反实现</li>
<li>新建一个对象重写 <code>__lt__</code> 魔术方法。这种方式也可以，但是重写魔术方法修改了语义不太好(个人不推荐)</li>
</ol>
<pre><code class="language-py"># 方法1:封装一个 max heap 类
import heapq
class MaxHeap:
    &quot;&quot;&quot;
    https://stackoverflow.com/questions/2501457/what-do-i-use-for-a-max-heap-implementation-in-python
    &quot;&quot;&quot;
    def __init__(self, capacity):
        self.capacity = capacity
        self.minheap = []

    def push(self, val):
        heapq.heappush(self.minheap, -val)  # push取反后的数字, 1 -&gt; -1

    def pop(self):
        val = heapq.heappop(self.minheap)
        return -val # 拿出来的数字再取反

    def max(self):
        return -self.minheap[0] # min-heap 的数组最小值是 m[0]，最大值取反

# 方法2: 重新定几个新的 max-heap 方法
import heapq
def maxheappush(h, item):
    return heapq.heappush(h, -item)

def maxheappop(h):
    return -heapq.heappop(h)

def maxheapval(h):
    return -h[0]
</code></pre>
<h1 id="lru_cachecache">lru_cache/cache 优化记忆化搜索</h1>
<p>python3 functools 模块的 cache 功能和 lru_cache(maxsize=None) 一样，不过更加轻量更快。在记忆化递归搜索的时候很方便。
注意这里的参数 <code>maxsize=None</code> 一定要设置为 None，否则默认的 maxsize=128。
举一个力扣上的例子，如果不加 cache 递归函数因为会大量重复计算直接超时，但是加一个装饰器就可以通过。
当然了如果你用 python2 没有这个装饰器，你可以直接用 python 的 dict 来实现。(存在就返回，否则计算结果保存到 dict 里)</p>
<pre><code class="language-py">&quot;&quot;&quot;
[337] 打家劫舍 III
https://leetcode-cn.com/problems/house-robber-iii/description/
&quot;&quot;&quot;
# cache 等价于 functools.lru_cache(maxsize=None), 不过python3版本低可能没有 cache 只有 lru_cache
from functools import cache, lru_cache


class Solution(object):
    def rob(self, root):
        &quot;&quot;&quot;
        思路 1：递归求解（注意不加 cache 会超时！！)
        :type root: TreeNode
        :rtype: int
        &quot;&quot;&quot;
        # @lru_cache(maxsize=None) # 注意如果 python3 版本不是很新的话，只能用 lru_cache(maxsize=None)
        @cache  # NOTE: 不加 cache 会直接超时，就只能用动态规划了
        def dfs(root):
            if root is None:
                return 0

            if root.left is None and root.right is None:  # 左右孩子都是空
                return root.val
            # 不偷父节点,考虑偷 root 的左右孩子
            val1 = dfs(root.left) + dfs(root.right)
            # 偷父节点
            val2 = root.val
            if root.left:
                val2 += dfs(root.left.left) + dfs(root.left.right)
            if root.right:
                val2 += dfs(root.right.left) + dfs(root.right.right)
            return max(val1, val2)

        return dfs(root)

</code></pre>
<h1 id="leetcode">leetcode 二叉树调试函数</h1>
<pre><code class="language-py">&quot;&quot;&quot;
二叉树树相关问题调试函数
&quot;&quot;&quot;


class TreeNode(object):  # leetcode tree 节点定义
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

    def __str__(self):
        return &quot;TreeNode:{} left:{} right:{}&quot;.format(self.val, self.left, self.right)
    __repr__ = __str__


def gen_tree_from_lc_input(vals_str):  # [1,2,3] -&gt; root TreeNode
    &quot;&quot;&quot; 根据 输入生成一个 tree，返回 root 节点，注意输入字符串
    # [450] 删除二叉搜索树中的节点
    # https://leetcode-cn.com/problems/delete-node-in-a-bst/description/
    # 比如 450 题目单测代码可以这么写
    def test():
        s = Solution()
        root = gen_tree_from_lc_input(&quot;[2,1]&quot;)
        key = 1
        res = &quot;[2]&quot;
        assert to_lc_tree_str(s.deleteNode(root, key)) == res
    &quot;&quot;&quot;
    import ast
    valids = vals_str.replace(&quot;null&quot;, &quot;None&quot;)
    vals = ast.literal_eval(valids)
    # 以下就是 gen_tree 函数的内容，为了方便单独使用不调用函数了
    if not vals:
        return None
    nodemap = {}
    for i in range(len(vals)):
        if vals[i] is not None:  # 一开始写的 if vals[i]，但是 0 节点就错了! 应该显示判断是否为 None(空节点)
            nodemap[i] = TreeNode(vals[i])
        else:
            nodemap[i] = None

    root = nodemap[0]
    for i in range(len(vals)):
        l = 2*i + 1
        r = 2*i + 2
        cur = nodemap.get(i, None)
        left = nodemap.get(l, None)
        right = nodemap.get(r, None)
        if cur:
            cur.left = left
            cur.right = right
    return root


def to_lc_tree_str(root):  # root TreeNode -&gt; [1,2,3,null]
    &quot;&quot;&quot;返回层序序列化后的树字符串，可以和 leetcode 输出结果比对字符串&quot;&quot;&quot;
    import json
    if not root:
        return '[]'
    curnodes = [root]
    res = [root.val]
    while curnodes:
        nextnodes = []
        for node in curnodes:
            if node:
                if node.left:
                    nextnodes.append(node.left)
                    res.append(node.left.val)
                else:
                    nextnodes.append(None)
                    res.append(None)
                if node.right:
                    nextnodes.append(node.right)
                    res.append(node.right.val)
                else:
                    nextnodes.append(None)
                    res.append(None)
        curnodes = nextnodes

    while res[-1] is None:  # 最后空节点去掉
        res.pop()
    s = json.dumps(res)
    s = s.replace(&quot; &quot;, &quot;&quot;)
    return s


def gen_tree(vals):
    &quot;&quot;&quot;
    根据层序遍历结果生成二叉树并且返回 root。
    把题目中输入 null 换成 None
    vals = [1,2,3,None,5]
    &quot;&quot;&quot;
    if not vals:
        return None
    nodemap = {}
    for i in range(len(vals)):
        if vals[i]:
            nodemap[i] = TreeNode(vals[i])
        else:
            nodemap[i] = None

    root = nodemap[0]
    for i in range(len(vals)):
        l = 2*i + 1
        r = 2*i + 2
        cur = nodemap.get(i, None)
        left = nodemap.get(l, None)
        right = nodemap.get(r, None)
        if cur:
            cur.left = left
            cur.right = right
    return root
</code></pre>
<h1 id="python_4">python 交换列表元素的坑(交换副作用)</h1>
<pre><code># 41. 缺失的第一个正数 https://leetcode-cn.com/problems/first-missing-positive/
class Solution(object):
    def firstMissingPositive(self, nums):
        &quot;&quot;&quot;
        平常习惯了 python 里边交换元素 a,b=b,a 这里你可能这么写，那就中招了!
        nums[i], nums[nums[i]-1] =  nums[nums[i]-1], nums[i] # 这么写死循环！
        这个等价于
        x, y = nums[nums[i]-1], nums[i]
        nums[i] = x  # 这一步 nums[i] 已经修改了，下边一句赋值不是期望的 nums[i]了
        nums[nums[i]-1] = y

        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        n = len(nums)
        for i in range(n):
            while 1 &lt;= nums[i] &lt;= n and nums[nums[i]-1] != nums[i]:
                # NOTE: 注意这一句交换右边有副作用的，不能颠倒！！！
                # nums[i], nums[nums[i]-1] =  nums[nums[i]-1], nums[i] # 这么写死循环！
                nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1] # 有副作用的放前边
        for i in range(n):
            if nums[i] != i+1:
                return i+1

        return n+1
</code></pre>
<h1 id="acm">兼容代码ACM/核心提交格式</h1>
<p>注意牛客网有两种模式，一种是和 leetcode 一样的提交(无需处理输入)，只需要提交核心代码。
一种是 ACM 模式，还需要自己处理输入和输出。
建议使用这种兼容写法，同样的题目可以同时提交到 牛客、leetcode 和 acwing(python3)。
这道题目为例子 [679] 奖品分配 https://www.acwing.com/problem/content/681/</p>
<pre><code class="language-py"># 这段代码可以直接以OJ输入模式提交，如果题目一样，直接复制 Solution 类就可以同时提交到leetcode
class Solution:
    def solve(self, scores):
        &quot;&quot;&quot;
        思路：记忆化搜索。时间O(N)
        对于旁边都比自己大的点，它肯定是1
        对于旁边有比自己小的点，先算出比自己小的点的值再+1就好了。
        每个点如果计算过了就记忆化，下次再计算他的时候不用重复递归直接返回。
        参考：https://www.acwing.com/solution/acwing/content/1520/
        &quot;&quot;&quot;
        from functools import lru_cache
        n = len(scores)

        @lru_cache(maxsize=None)
        def dfs(x):
            left = (x-1+n) % n
            right = (x+1) % n

            if scores[x] &lt;= scores[left] and scores[x] &lt;= scores[right]:  # 注意是 &lt;= ，下边是 &lt;
                return 1

            l, r = 0, 0
            if scores[left] &lt; scores[x]:
                l = dfs(left)
            if scores[right] &lt; scores[x]:
                r = dfs(right)

            return max(l, r) + 1

        return sum([dfs(i) for i in range(n)])


if __name__ == &quot;__main__&quot;:  # python3 提交，python3 input 都当做 str 输入
    so = Solution() # 构造 Solution 实例后续调用
    n = int(input())
    for i in range(n):
        arrlen = input()
        arr = list(map(int, input().split()))
        print(so.solve(arr))
</code></pre>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../../18_%E5%9B%BE%E4%B8%8E%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/graph/" class="btn btn-neutral float-left" title="18_图与图的遍历"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../../20_%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/interview/" class="btn btn-neutral float-right" title="20_面试指南">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../../18_%E5%9B%BE%E4%B8%8E%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/graph/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../../20_%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/interview/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
